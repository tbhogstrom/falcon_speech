import _styled from "@emotion/styled/base";
import _partial from "lodash/partial";
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
import React from 'react';
import PropTypes from 'prop-types';
import ImmutablePropTypes from 'react-immutable-proptypes';
import { connect } from 'react-redux';
import { translate } from 'react-polyglot';
import { Cursor } from 'decap-cms-lib-util';
import { colors } from 'decap-cms-ui-default';
import { loadEntries as actionLoadEntries, traverseCollectionCursor as actionTraverseCollectionCursor } from '../../../actions/entries';
import { selectEntries, selectEntriesLoaded, selectIsFetching, selectGroups } from '../../../reducers/entries';
import { selectCollectionEntriesCursor } from '../../../reducers/cursors';
import Entries from './Entries';
import { jsx as ___EmotionJSX } from "@emotion/react";
const GroupHeading = /*#__PURE__*/_styled("h2", {
  target: "eucqz2q1",
  label: "GroupHeading"
})("font-size:22px;font-weight:600;line-height:37px;padding-inline-start:20px;color:", colors.textLead, ";" + (process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0NvbGxlY3Rpb24vRW50cmllcy9FbnRyaWVzQ29sbGVjdGlvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUF1QjhCIiwiZmlsZSI6Ii4uLy4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0NvbGxlY3Rpb24vRW50cmllcy9FbnRyaWVzQ29sbGVjdGlvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEltbXV0YWJsZVByb3BUeXBlcyBmcm9tICdyZWFjdC1pbW11dGFibGUtcHJvcHR5cGVzJztcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICdyZWFjdC1wb2x5Z2xvdCc7XG5pbXBvcnQgeyBwYXJ0aWFsIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IEN1cnNvciB9IGZyb20gJ2RlY2FwLWNtcy1saWItdXRpbCc7XG5pbXBvcnQgeyBjb2xvcnMgfSBmcm9tICdkZWNhcC1jbXMtdWktZGVmYXVsdCc7XG5cbmltcG9ydCB7XG4gIGxvYWRFbnRyaWVzIGFzIGFjdGlvbkxvYWRFbnRyaWVzLFxuICB0cmF2ZXJzZUNvbGxlY3Rpb25DdXJzb3IgYXMgYWN0aW9uVHJhdmVyc2VDb2xsZWN0aW9uQ3Vyc29yLFxufSBmcm9tICcuLi8uLi8uLi9hY3Rpb25zL2VudHJpZXMnO1xuaW1wb3J0IHtcbiAgc2VsZWN0RW50cmllcyxcbiAgc2VsZWN0RW50cmllc0xvYWRlZCxcbiAgc2VsZWN0SXNGZXRjaGluZyxcbiAgc2VsZWN0R3JvdXBzLFxufSBmcm9tICcuLi8uLi8uLi9yZWR1Y2Vycy9lbnRyaWVzJztcbmltcG9ydCB7IHNlbGVjdENvbGxlY3Rpb25FbnRyaWVzQ3Vyc29yIH0gZnJvbSAnLi4vLi4vLi4vcmVkdWNlcnMvY3Vyc29ycyc7XG5pbXBvcnQgRW50cmllcyBmcm9tICcuL0VudHJpZXMnO1xuXG5jb25zdCBHcm91cEhlYWRpbmcgPSBzdHlsZWQuaDJgXG4gIGZvbnQtc2l6ZTogMjJweDtcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgbGluZS1oZWlnaHQ6IDM3cHg7XG4gIHBhZGRpbmctaW5saW5lLXN0YXJ0OiAyMHB4O1xuICBjb2xvcjogJHtjb2xvcnMudGV4dExlYWR9O1xuYDtcblxuY29uc3QgR3JvdXBDb250YWluZXIgPSBzdHlsZWQuZGl2YGA7XG5cbmZ1bmN0aW9uIGdldEdyb3VwRW50cmllcyhlbnRyaWVzLCBwYXRocykge1xuICByZXR1cm4gZW50cmllcy5maWx0ZXIoZW50cnkgPT4gcGF0aHMuaGFzKGVudHJ5LmdldCgncGF0aCcpKSk7XG59XG5cbmZ1bmN0aW9uIGdldEdyb3VwVGl0bGUoZ3JvdXAsIHQpIHtcbiAgY29uc3QgeyBsYWJlbCwgdmFsdWUgfSA9IGdyb3VwO1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0KCdjb2xsZWN0aW9uLmdyb3Vwcy5vdGhlcicpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiB2YWx1ZSA/IGxhYmVsIDogdCgnY29sbGVjdGlvbi5ncm91cHMubmVnYXRlTGFiZWwnLCB7IGxhYmVsIH0pO1xuICB9XG4gIHJldHVybiBgJHtsYWJlbH0gJHt2YWx1ZX1gLnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gd2l0aEdyb3Vwcyhncm91cHMsIGVudHJpZXMsIEVudHJpZXNUb1JlbmRlciwgdCkge1xuICByZXR1cm4gZ3JvdXBzLm1hcChncm91cCA9PiB7XG4gICAgY29uc3QgdGl0bGUgPSBnZXRHcm91cFRpdGxlKGdyb3VwLCB0KTtcbiAgICByZXR1cm4gKFxuICAgICAgPEdyb3VwQ29udGFpbmVyIGtleT17Z3JvdXAuaWR9IGlkPXtncm91cC5pZH0+XG4gICAgICAgIDxHcm91cEhlYWRpbmc+e3RpdGxlfTwvR3JvdXBIZWFkaW5nPlxuICAgICAgICA8RW50cmllc1RvUmVuZGVyIGVudHJpZXM9e2dldEdyb3VwRW50cmllcyhlbnRyaWVzLCBncm91cC5wYXRocyl9IC8+XG4gICAgICA8L0dyb3VwQ29udGFpbmVyPlxuICAgICk7XG4gIH0pO1xufVxuXG5leHBvcnQgY2xhc3MgRW50cmllc0NvbGxlY3Rpb24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGNvbGxlY3Rpb246IEltbXV0YWJsZVByb3BUeXBlcy5tYXAuaXNSZXF1aXJlZCxcbiAgICBwYWdlOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGVudHJpZXM6IEltbXV0YWJsZVByb3BUeXBlcy5saXN0LFxuICAgIGdyb3VwczogUHJvcFR5cGVzLmFycmF5LFxuICAgIGlzRmV0Y2hpbmc6IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG4gICAgdmlld1N0eWxlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGN1cnNvcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgIGxvYWRFbnRyaWVzOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHRyYXZlcnNlQ29sbGVjdGlvbkN1cnNvcjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBlbnRyaWVzTG9hZGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgfTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCB7IGNvbGxlY3Rpb24sIGVudHJpZXNMb2FkZWQsIGxvYWRFbnRyaWVzIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChjb2xsZWN0aW9uICYmICFlbnRyaWVzTG9hZGVkKSB7XG4gICAgICBsb2FkRW50cmllcyhjb2xsZWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgY29uc3QgeyBjb2xsZWN0aW9uLCBlbnRyaWVzTG9hZGVkLCBsb2FkRW50cmllcyB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoY29sbGVjdGlvbiAhPT0gcHJldlByb3BzLmNvbGxlY3Rpb24gJiYgIWVudHJpZXNMb2FkZWQpIHtcbiAgICAgIGxvYWRFbnRyaWVzKGNvbGxlY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUN1cnNvckFjdGlvbnMgPSAoY3Vyc29yLCBhY3Rpb24pID0+IHtcbiAgICBjb25zdCB7IGNvbGxlY3Rpb24sIHRyYXZlcnNlQ29sbGVjdGlvbkN1cnNvciB9ID0gdGhpcy5wcm9wcztcbiAgICB0cmF2ZXJzZUNvbGxlY3Rpb25DdXJzb3IoY29sbGVjdGlvbiwgYWN0aW9uKTtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjb2xsZWN0aW9uLCBlbnRyaWVzLCBncm91cHMsIGlzRmV0Y2hpbmcsIHZpZXdTdHlsZSwgY3Vyc29yLCBwYWdlLCB0IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgRW50cmllc1RvUmVuZGVyID0gKHsgZW50cmllcyB9KSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8RW50cmllc1xuICAgICAgICAgIGNvbGxlY3Rpb25zPXtjb2xsZWN0aW9ufVxuICAgICAgICAgIGVudHJpZXM9e2VudHJpZXN9XG4gICAgICAgICAgaXNGZXRjaGluZz17aXNGZXRjaGluZ31cbiAgICAgICAgICBjb2xsZWN0aW9uTmFtZT17Y29sbGVjdGlvbi5nZXQoJ2xhYmVsJyl9XG4gICAgICAgICAgdmlld1N0eWxlPXt2aWV3U3R5bGV9XG4gICAgICAgICAgY3Vyc29yPXtjdXJzb3J9XG4gICAgICAgICAgaGFuZGxlQ3Vyc29yQWN0aW9ucz17cGFydGlhbCh0aGlzLmhhbmRsZUN1cnNvckFjdGlvbnMsIGN1cnNvcil9XG4gICAgICAgICAgcGFnZT17cGFnZX1cbiAgICAgICAgLz5cbiAgICAgICk7XG4gICAgfTtcblxuICAgIGlmIChncm91cHMgJiYgZ3JvdXBzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB3aXRoR3JvdXBzKGdyb3VwcywgZW50cmllcywgRW50cmllc1RvUmVuZGVyLCB0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gPEVudHJpZXNUb1JlbmRlciBlbnRyaWVzPXtlbnRyaWVzfSAvPjtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyTmVzdGVkRW50cmllcyhwYXRoLCBjb2xsZWN0aW9uRm9sZGVyLCBlbnRyaWVzKSB7XG4gIGNvbnN0IGZpbHRlcmVkID0gZW50cmllcy5maWx0ZXIoZSA9PiB7XG4gICAgbGV0IGVudHJ5UGF0aCA9IGUuZ2V0KCdwYXRoJykuc2xpY2UoY29sbGVjdGlvbkZvbGRlci5sZW5ndGggKyAxKTtcbiAgICBpZiAoIWVudHJ5UGF0aC5zdGFydHNXaXRoKHBhdGgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gZm9yIHN1YmRpcmVjdG9yaWVzLCB0cmltIG9mZiB0aGUgcGFyZW50IGZvbGRlciBjb3JyZXNwb25kaW5nIHRvXG4gICAgLy8gdGhpcyBuZXN0ZWQgY29sbGVjdGlvbiBlbnRyeVxuICAgIGlmIChwYXRoKSB7XG4gICAgICBlbnRyeVBhdGggPSBlbnRyeVBhdGguc2xpY2UocGF0aC5sZW5ndGggKyAxKTtcbiAgICB9XG5cbiAgICAvLyBvbmx5IHNob3cgaW1tZWRpYXRlIGNoaWxkcmVuXG4gICAgcmV0dXJuICFlbnRyeVBhdGguaW5jbHVkZXMoJy8nKTtcbiAgfSk7XG4gIHJldHVybiBmaWx0ZXJlZDtcbn1cblxuZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcykge1xuICBjb25zdCB7IGNvbGxlY3Rpb24sIHZpZXdTdHlsZSwgZmlsdGVyVGVybSB9ID0gb3duUHJvcHM7XG4gIGNvbnN0IHBhZ2UgPSBzdGF0ZS5lbnRyaWVzLmdldEluKFsncGFnZXMnLCBjb2xsZWN0aW9uLmdldCgnbmFtZScpLCAncGFnZSddKTtcblxuICBsZXQgZW50cmllcyA9IHNlbGVjdEVudHJpZXMoc3RhdGUuZW50cmllcywgY29sbGVjdGlvbik7XG4gIGNvbnN0IGdyb3VwcyA9IHNlbGVjdEdyb3VwcyhzdGF0ZS5lbnRyaWVzLCBjb2xsZWN0aW9uKTtcblxuICBpZiAoY29sbGVjdGlvbi5oYXMoJ25lc3RlZCcpKSB7XG4gICAgY29uc3QgY29sbGVjdGlvbkZvbGRlciA9IGNvbGxlY3Rpb24uZ2V0KCdmb2xkZXInKTtcbiAgICBlbnRyaWVzID0gZmlsdGVyTmVzdGVkRW50cmllcyhmaWx0ZXJUZXJtIHx8ICcnLCBjb2xsZWN0aW9uRm9sZGVyLCBlbnRyaWVzKTtcbiAgfVxuICBjb25zdCBlbnRyaWVzTG9hZGVkID0gc2VsZWN0RW50cmllc0xvYWRlZChzdGF0ZS5lbnRyaWVzLCBjb2xsZWN0aW9uLmdldCgnbmFtZScpKTtcbiAgY29uc3QgaXNGZXRjaGluZyA9IHNlbGVjdElzRmV0Y2hpbmcoc3RhdGUuZW50cmllcywgY29sbGVjdGlvbi5nZXQoJ25hbWUnKSk7XG5cbiAgY29uc3QgcmF3Q3Vyc29yID0gc2VsZWN0Q29sbGVjdGlvbkVudHJpZXNDdXJzb3Ioc3RhdGUuY3Vyc29ycywgY29sbGVjdGlvbi5nZXQoJ25hbWUnKSk7XG4gIGNvbnN0IGN1cnNvciA9IEN1cnNvci5jcmVhdGUocmF3Q3Vyc29yKS5jbGVhckRhdGEoKTtcblxuICByZXR1cm4geyBjb2xsZWN0aW9uLCBwYWdlLCBlbnRyaWVzLCBncm91cHMsIGVudHJpZXNMb2FkZWQsIGlzRmV0Y2hpbmcsIHZpZXdTdHlsZSwgY3Vyc29yIH07XG59XG5cbmNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyA9IHtcbiAgbG9hZEVudHJpZXM6IGFjdGlvbkxvYWRFbnRyaWVzLFxuICB0cmF2ZXJzZUNvbGxlY3Rpb25DdXJzb3I6IGFjdGlvblRyYXZlcnNlQ29sbGVjdGlvbkN1cnNvcixcbn07XG5cbmNvbnN0IENvbm5lY3RlZEVudHJpZXNDb2xsZWN0aW9uID0gY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcykoRW50cmllc0NvbGxlY3Rpb24pO1xuXG5leHBvcnQgZGVmYXVsdCB0cmFuc2xhdGUoKShDb25uZWN0ZWRFbnRyaWVzQ29sbGVjdGlvbik7XG4iXX0= */"));
const GroupContainer = /*#__PURE__*/_styled("div", {
  target: "eucqz2q0",
  label: "GroupContainer"
})(process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0NvbGxlY3Rpb24vRW50cmllcy9FbnRyaWVzQ29sbGVjdGlvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUErQmlDIiwiZmlsZSI6Ii4uLy4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0NvbGxlY3Rpb24vRW50cmllcy9FbnRyaWVzQ29sbGVjdGlvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEltbXV0YWJsZVByb3BUeXBlcyBmcm9tICdyZWFjdC1pbW11dGFibGUtcHJvcHR5cGVzJztcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICdyZWFjdC1wb2x5Z2xvdCc7XG5pbXBvcnQgeyBwYXJ0aWFsIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IEN1cnNvciB9IGZyb20gJ2RlY2FwLWNtcy1saWItdXRpbCc7XG5pbXBvcnQgeyBjb2xvcnMgfSBmcm9tICdkZWNhcC1jbXMtdWktZGVmYXVsdCc7XG5cbmltcG9ydCB7XG4gIGxvYWRFbnRyaWVzIGFzIGFjdGlvbkxvYWRFbnRyaWVzLFxuICB0cmF2ZXJzZUNvbGxlY3Rpb25DdXJzb3IgYXMgYWN0aW9uVHJhdmVyc2VDb2xsZWN0aW9uQ3Vyc29yLFxufSBmcm9tICcuLi8uLi8uLi9hY3Rpb25zL2VudHJpZXMnO1xuaW1wb3J0IHtcbiAgc2VsZWN0RW50cmllcyxcbiAgc2VsZWN0RW50cmllc0xvYWRlZCxcbiAgc2VsZWN0SXNGZXRjaGluZyxcbiAgc2VsZWN0R3JvdXBzLFxufSBmcm9tICcuLi8uLi8uLi9yZWR1Y2Vycy9lbnRyaWVzJztcbmltcG9ydCB7IHNlbGVjdENvbGxlY3Rpb25FbnRyaWVzQ3Vyc29yIH0gZnJvbSAnLi4vLi4vLi4vcmVkdWNlcnMvY3Vyc29ycyc7XG5pbXBvcnQgRW50cmllcyBmcm9tICcuL0VudHJpZXMnO1xuXG5jb25zdCBHcm91cEhlYWRpbmcgPSBzdHlsZWQuaDJgXG4gIGZvbnQtc2l6ZTogMjJweDtcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgbGluZS1oZWlnaHQ6IDM3cHg7XG4gIHBhZGRpbmctaW5saW5lLXN0YXJ0OiAyMHB4O1xuICBjb2xvcjogJHtjb2xvcnMudGV4dExlYWR9O1xuYDtcblxuY29uc3QgR3JvdXBDb250YWluZXIgPSBzdHlsZWQuZGl2YGA7XG5cbmZ1bmN0aW9uIGdldEdyb3VwRW50cmllcyhlbnRyaWVzLCBwYXRocykge1xuICByZXR1cm4gZW50cmllcy5maWx0ZXIoZW50cnkgPT4gcGF0aHMuaGFzKGVudHJ5LmdldCgncGF0aCcpKSk7XG59XG5cbmZ1bmN0aW9uIGdldEdyb3VwVGl0bGUoZ3JvdXAsIHQpIHtcbiAgY29uc3QgeyBsYWJlbCwgdmFsdWUgfSA9IGdyb3VwO1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0KCdjb2xsZWN0aW9uLmdyb3Vwcy5vdGhlcicpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiB2YWx1ZSA/IGxhYmVsIDogdCgnY29sbGVjdGlvbi5ncm91cHMubmVnYXRlTGFiZWwnLCB7IGxhYmVsIH0pO1xuICB9XG4gIHJldHVybiBgJHtsYWJlbH0gJHt2YWx1ZX1gLnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gd2l0aEdyb3Vwcyhncm91cHMsIGVudHJpZXMsIEVudHJpZXNUb1JlbmRlciwgdCkge1xuICByZXR1cm4gZ3JvdXBzLm1hcChncm91cCA9PiB7XG4gICAgY29uc3QgdGl0bGUgPSBnZXRHcm91cFRpdGxlKGdyb3VwLCB0KTtcbiAgICByZXR1cm4gKFxuICAgICAgPEdyb3VwQ29udGFpbmVyIGtleT17Z3JvdXAuaWR9IGlkPXtncm91cC5pZH0+XG4gICAgICAgIDxHcm91cEhlYWRpbmc+e3RpdGxlfTwvR3JvdXBIZWFkaW5nPlxuICAgICAgICA8RW50cmllc1RvUmVuZGVyIGVudHJpZXM9e2dldEdyb3VwRW50cmllcyhlbnRyaWVzLCBncm91cC5wYXRocyl9IC8+XG4gICAgICA8L0dyb3VwQ29udGFpbmVyPlxuICAgICk7XG4gIH0pO1xufVxuXG5leHBvcnQgY2xhc3MgRW50cmllc0NvbGxlY3Rpb24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGNvbGxlY3Rpb246IEltbXV0YWJsZVByb3BUeXBlcy5tYXAuaXNSZXF1aXJlZCxcbiAgICBwYWdlOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGVudHJpZXM6IEltbXV0YWJsZVByb3BUeXBlcy5saXN0LFxuICAgIGdyb3VwczogUHJvcFR5cGVzLmFycmF5LFxuICAgIGlzRmV0Y2hpbmc6IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG4gICAgdmlld1N0eWxlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGN1cnNvcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgIGxvYWRFbnRyaWVzOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHRyYXZlcnNlQ29sbGVjdGlvbkN1cnNvcjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBlbnRyaWVzTG9hZGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgfTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCB7IGNvbGxlY3Rpb24sIGVudHJpZXNMb2FkZWQsIGxvYWRFbnRyaWVzIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChjb2xsZWN0aW9uICYmICFlbnRyaWVzTG9hZGVkKSB7XG4gICAgICBsb2FkRW50cmllcyhjb2xsZWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgY29uc3QgeyBjb2xsZWN0aW9uLCBlbnRyaWVzTG9hZGVkLCBsb2FkRW50cmllcyB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoY29sbGVjdGlvbiAhPT0gcHJldlByb3BzLmNvbGxlY3Rpb24gJiYgIWVudHJpZXNMb2FkZWQpIHtcbiAgICAgIGxvYWRFbnRyaWVzKGNvbGxlY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUN1cnNvckFjdGlvbnMgPSAoY3Vyc29yLCBhY3Rpb24pID0+IHtcbiAgICBjb25zdCB7IGNvbGxlY3Rpb24sIHRyYXZlcnNlQ29sbGVjdGlvbkN1cnNvciB9ID0gdGhpcy5wcm9wcztcbiAgICB0cmF2ZXJzZUNvbGxlY3Rpb25DdXJzb3IoY29sbGVjdGlvbiwgYWN0aW9uKTtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjb2xsZWN0aW9uLCBlbnRyaWVzLCBncm91cHMsIGlzRmV0Y2hpbmcsIHZpZXdTdHlsZSwgY3Vyc29yLCBwYWdlLCB0IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgRW50cmllc1RvUmVuZGVyID0gKHsgZW50cmllcyB9KSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8RW50cmllc1xuICAgICAgICAgIGNvbGxlY3Rpb25zPXtjb2xsZWN0aW9ufVxuICAgICAgICAgIGVudHJpZXM9e2VudHJpZXN9XG4gICAgICAgICAgaXNGZXRjaGluZz17aXNGZXRjaGluZ31cbiAgICAgICAgICBjb2xsZWN0aW9uTmFtZT17Y29sbGVjdGlvbi5nZXQoJ2xhYmVsJyl9XG4gICAgICAgICAgdmlld1N0eWxlPXt2aWV3U3R5bGV9XG4gICAgICAgICAgY3Vyc29yPXtjdXJzb3J9XG4gICAgICAgICAgaGFuZGxlQ3Vyc29yQWN0aW9ucz17cGFydGlhbCh0aGlzLmhhbmRsZUN1cnNvckFjdGlvbnMsIGN1cnNvcil9XG4gICAgICAgICAgcGFnZT17cGFnZX1cbiAgICAgICAgLz5cbiAgICAgICk7XG4gICAgfTtcblxuICAgIGlmIChncm91cHMgJiYgZ3JvdXBzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB3aXRoR3JvdXBzKGdyb3VwcywgZW50cmllcywgRW50cmllc1RvUmVuZGVyLCB0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gPEVudHJpZXNUb1JlbmRlciBlbnRyaWVzPXtlbnRyaWVzfSAvPjtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyTmVzdGVkRW50cmllcyhwYXRoLCBjb2xsZWN0aW9uRm9sZGVyLCBlbnRyaWVzKSB7XG4gIGNvbnN0IGZpbHRlcmVkID0gZW50cmllcy5maWx0ZXIoZSA9PiB7XG4gICAgbGV0IGVudHJ5UGF0aCA9IGUuZ2V0KCdwYXRoJykuc2xpY2UoY29sbGVjdGlvbkZvbGRlci5sZW5ndGggKyAxKTtcbiAgICBpZiAoIWVudHJ5UGF0aC5zdGFydHNXaXRoKHBhdGgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gZm9yIHN1YmRpcmVjdG9yaWVzLCB0cmltIG9mZiB0aGUgcGFyZW50IGZvbGRlciBjb3JyZXNwb25kaW5nIHRvXG4gICAgLy8gdGhpcyBuZXN0ZWQgY29sbGVjdGlvbiBlbnRyeVxuICAgIGlmIChwYXRoKSB7XG4gICAgICBlbnRyeVBhdGggPSBlbnRyeVBhdGguc2xpY2UocGF0aC5sZW5ndGggKyAxKTtcbiAgICB9XG5cbiAgICAvLyBvbmx5IHNob3cgaW1tZWRpYXRlIGNoaWxkcmVuXG4gICAgcmV0dXJuICFlbnRyeVBhdGguaW5jbHVkZXMoJy8nKTtcbiAgfSk7XG4gIHJldHVybiBmaWx0ZXJlZDtcbn1cblxuZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcykge1xuICBjb25zdCB7IGNvbGxlY3Rpb24sIHZpZXdTdHlsZSwgZmlsdGVyVGVybSB9ID0gb3duUHJvcHM7XG4gIGNvbnN0IHBhZ2UgPSBzdGF0ZS5lbnRyaWVzLmdldEluKFsncGFnZXMnLCBjb2xsZWN0aW9uLmdldCgnbmFtZScpLCAncGFnZSddKTtcblxuICBsZXQgZW50cmllcyA9IHNlbGVjdEVudHJpZXMoc3RhdGUuZW50cmllcywgY29sbGVjdGlvbik7XG4gIGNvbnN0IGdyb3VwcyA9IHNlbGVjdEdyb3VwcyhzdGF0ZS5lbnRyaWVzLCBjb2xsZWN0aW9uKTtcblxuICBpZiAoY29sbGVjdGlvbi5oYXMoJ25lc3RlZCcpKSB7XG4gICAgY29uc3QgY29sbGVjdGlvbkZvbGRlciA9IGNvbGxlY3Rpb24uZ2V0KCdmb2xkZXInKTtcbiAgICBlbnRyaWVzID0gZmlsdGVyTmVzdGVkRW50cmllcyhmaWx0ZXJUZXJtIHx8ICcnLCBjb2xsZWN0aW9uRm9sZGVyLCBlbnRyaWVzKTtcbiAgfVxuICBjb25zdCBlbnRyaWVzTG9hZGVkID0gc2VsZWN0RW50cmllc0xvYWRlZChzdGF0ZS5lbnRyaWVzLCBjb2xsZWN0aW9uLmdldCgnbmFtZScpKTtcbiAgY29uc3QgaXNGZXRjaGluZyA9IHNlbGVjdElzRmV0Y2hpbmcoc3RhdGUuZW50cmllcywgY29sbGVjdGlvbi5nZXQoJ25hbWUnKSk7XG5cbiAgY29uc3QgcmF3Q3Vyc29yID0gc2VsZWN0Q29sbGVjdGlvbkVudHJpZXNDdXJzb3Ioc3RhdGUuY3Vyc29ycywgY29sbGVjdGlvbi5nZXQoJ25hbWUnKSk7XG4gIGNvbnN0IGN1cnNvciA9IEN1cnNvci5jcmVhdGUocmF3Q3Vyc29yKS5jbGVhckRhdGEoKTtcblxuICByZXR1cm4geyBjb2xsZWN0aW9uLCBwYWdlLCBlbnRyaWVzLCBncm91cHMsIGVudHJpZXNMb2FkZWQsIGlzRmV0Y2hpbmcsIHZpZXdTdHlsZSwgY3Vyc29yIH07XG59XG5cbmNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyA9IHtcbiAgbG9hZEVudHJpZXM6IGFjdGlvbkxvYWRFbnRyaWVzLFxuICB0cmF2ZXJzZUNvbGxlY3Rpb25DdXJzb3I6IGFjdGlvblRyYXZlcnNlQ29sbGVjdGlvbkN1cnNvcixcbn07XG5cbmNvbnN0IENvbm5lY3RlZEVudHJpZXNDb2xsZWN0aW9uID0gY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcykoRW50cmllc0NvbGxlY3Rpb24pO1xuXG5leHBvcnQgZGVmYXVsdCB0cmFuc2xhdGUoKShDb25uZWN0ZWRFbnRyaWVzQ29sbGVjdGlvbik7XG4iXX0= */");
function getGroupEntries(entries, paths) {
  return entries.filter(entry => paths.has(entry.get('path')));
}
function getGroupTitle(group, t) {
  const {
    label,
    value
  } = group;
  if (value === undefined) {
    return t('collection.groups.other');
  }
  if (typeof value === 'boolean') {
    return value ? label : t('collection.groups.negateLabel', {
      label
    });
  }
  return `${label} ${value}`.trim();
}
function withGroups(groups, entries, EntriesToRender, t) {
  return groups.map(group => {
    const title = getGroupTitle(group, t);
    return ___EmotionJSX(GroupContainer, {
      key: group.id,
      id: group.id
    }, ___EmotionJSX(GroupHeading, null, title), ___EmotionJSX(EntriesToRender, {
      entries: getGroupEntries(entries, group.paths)
    }));
  });
}
export class EntriesCollection extends React.Component {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "handleCursorActions", (cursor, action) => {
      const {
        collection,
        traverseCollectionCursor
      } = this.props;
      traverseCollectionCursor(collection, action);
    });
  }
  componentDidMount() {
    const {
      collection,
      entriesLoaded,
      loadEntries
    } = this.props;
    if (collection && !entriesLoaded) {
      loadEntries(collection);
    }
  }
  componentDidUpdate(prevProps) {
    const {
      collection,
      entriesLoaded,
      loadEntries
    } = this.props;
    if (collection !== prevProps.collection && !entriesLoaded) {
      loadEntries(collection);
    }
  }
  render() {
    const {
      collection,
      entries,
      groups,
      isFetching,
      viewStyle,
      cursor,
      page,
      t
    } = this.props;
    const EntriesToRender = ({
      entries
    }) => {
      return ___EmotionJSX(Entries, {
        collections: collection,
        entries: entries,
        isFetching: isFetching,
        collectionName: collection.get('label'),
        viewStyle: viewStyle,
        cursor: cursor,
        handleCursorActions: _partial(this.handleCursorActions, cursor),
        page: page
      });
    };
    if (groups && groups.length > 0) {
      return withGroups(groups, entries, EntriesToRender, t);
    }
    return ___EmotionJSX(EntriesToRender, {
      entries: entries
    });
  }
}
_defineProperty(EntriesCollection, "propTypes", {
  collection: ImmutablePropTypes.map.isRequired,
  page: PropTypes.number,
  entries: ImmutablePropTypes.list,
  groups: PropTypes.array,
  isFetching: PropTypes.bool.isRequired,
  viewStyle: PropTypes.string,
  cursor: PropTypes.object.isRequired,
  loadEntries: PropTypes.func.isRequired,
  traverseCollectionCursor: PropTypes.func.isRequired,
  entriesLoaded: PropTypes.bool
});
export function filterNestedEntries(path, collectionFolder, entries) {
  const filtered = entries.filter(e => {
    let entryPath = e.get('path').slice(collectionFolder.length + 1);
    if (!entryPath.startsWith(path)) {
      return false;
    }

    // for subdirectories, trim off the parent folder corresponding to
    // this nested collection entry
    if (path) {
      entryPath = entryPath.slice(path.length + 1);
    }

    // only show immediate children
    return !entryPath.includes('/');
  });
  return filtered;
}
function mapStateToProps(state, ownProps) {
  const {
    collection,
    viewStyle,
    filterTerm
  } = ownProps;
  const page = state.entries.getIn(['pages', collection.get('name'), 'page']);
  let entries = selectEntries(state.entries, collection);
  const groups = selectGroups(state.entries, collection);
  if (collection.has('nested')) {
    const collectionFolder = collection.get('folder');
    entries = filterNestedEntries(filterTerm || '', collectionFolder, entries);
  }
  const entriesLoaded = selectEntriesLoaded(state.entries, collection.get('name'));
  const isFetching = selectIsFetching(state.entries, collection.get('name'));
  const rawCursor = selectCollectionEntriesCursor(state.cursors, collection.get('name'));
  const cursor = Cursor.create(rawCursor).clearData();
  return {
    collection,
    page,
    entries,
    groups,
    entriesLoaded,
    isFetching,
    viewStyle,
    cursor
  };
}
const mapDispatchToProps = {
  loadEntries: actionLoadEntries,
  traverseCollectionCursor: actionTraverseCollectionCursor
};
const ConnectedEntriesCollection = connect(mapStateToProps, mapDispatchToProps)(EntriesCollection);
export default translate()(ConnectedEntriesCollection);